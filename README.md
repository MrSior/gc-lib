# GC Library
Сборщик мусора, реализующий алгоритм Mark-and-Sweep, для С программ с поддержкой многопоточности.

## Оглавление
- [Quickstart](#quickstart)
  - [Установка](#установка)
  - [Основное использование](#основное-использование)
- [Философия](#философия)

## Quickstart
### Установка
Установаите библиотику папку в директроию проекта.
```shell
git clone https://github.com/MrSior/gc-lib
```

В CMakeLists.txt проекта добвьте путь до директории ```/include``` библиотеки

```cmake
include_directories(<"путь до библиотеки">/gc-lib/include)
```

```cmake
# Пример
include_directories(${CMAKE_SOURCE_DIR}/gc-lib/include)
```

### Основное использование
Пример кода ```main.c```, используюший библиотеку
```c
#include <stdio.h>
#include <stdlib.h>
#include "gc/gc.h"

int main(int argc, char* argv[]) {
    GC_CREATE();
    int* val;
    GC_MARK_ROOT(val);
    GC_MALLOC(val, 4);

    *val = 123;
    printf("%d\n", *val);
    val = NULL;
    
    GC_COLLECT(THREAD_LOCAL);
    GC_STOP();

    return 0;
}
```

## Core API
Описание API, находящегося в [gc.h](./include/gc/gc.h)

### Создание GC
Для объявления сборщика мусора для данного потока небходимо вызвать функцию ```gc_create(pthread_t)```, в которую необходимо передать id данного потока. Рекомендуюется получать его при помощи ```pthread_self()```.

### Выделение памяти
Для вывделения памяти

## Концепция
Основной принцип библиотеки - это 1 поток, 1 сборщик мусора. Ядром библиотеки является thread-pool, через который проходят все операции с памятью от всех потоков. Поэтому для работы необходимо создать сборщик для данного потока и получить api-структуру с методами для работы с памятью и сборщиком мусора.


